<!DOCTYPE html>
<html>
<head>
	<link rel="stylesheet" href="../../game/main.css">
</head>
<body>
	<div id = "main_game_container" class = "fill" >
		<div .style = "position:absolute;top:0;left:0;">
		<input type="number" min = "5" max = "5">
		<canvas id = "main_game_canvas" .style = "position:relative;"></canvas>
		
	</div>
		
	</div>
	
	
	
	
	
	<script>
	//this file exists solely as a proof of concept for the tile collision engine.
	//at first the logic will reside here to provide a functioning example
	//then the logic module will be split off into the main physics system.
	//two 
		function beep() {
    var snd = new Audio("data:audio/wav;base64,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qJrx4KOQjahZxWbcZgztj2c49nKmkId44S71j0c8eV9yDK6uPRzx5X18eDvjvQ6yKo9ZSS6l//8elePK/Lf//IInrOF/FvDoADYAGBMGb7FtErm5MXMlmPAJQVgWta7Zx2go+8xJ0UiCb8LHHdftWyLJE0QIAIsI+UbXu67dZMjmgDGCGl1H+vpF4NSDckSIkk7Vd+sxEhBQMRU8j/12UIRhzSaUdQ+rQU5kGeFxm+hb1oh6pWWmv3uvmReDl0UnvtapVaIzo1jZbf/pD6ElLqSX+rUmOQNpJFa/r+sa4e/pBlAABoAAAAA3CUgShLdGIxsY7AUABPRrgCABdDuQ5GC7DqPQCgbbJUAoRSUj+NIEig0YfyWUho1VBBBA//uQZB4ABZx5zfMakeAAAAmwAAAAF5F3P0w9GtAAACfAAAAAwLhMDmAYWMgVEG1U0FIGCBgXBXAtfMH10000EEEEEECUBYln03TTTdNBDZopopYvrTTdNa325mImNg3TTPV9q3pmY0xoO6bv3r00y+IDGid/9aaaZTGMuj9mpu9Mpio1dXrr5HERTZSmqU36A3CumzN/9Robv/Xx4v9ijkSRSNLQhAWumap82WRSBUqXStV/YcS+XVLnSS+WLDroqArFkMEsAS+eWmrUzrO0oEmE40RlMZ5+ODIkAyKAGUwZ3mVKmcamcJnMW26MRPgUw6j+LkhyHGVGYjSUUKNpuJUQoOIAyDvEyG8S5yfK6dhZc0Tx1KI/gviKL6qvvFs1+bWtaz58uUNnryq6kt5RzOCkPWlVqVX2a/EEBUdU1KrXLf40GoiiFXK///qpoiDXrOgqDR38JB0bw7SoL+ZB9o1RCkQjQ2CBYZKd/+VJxZRRZlqSkKiws0WFxUyCwsKiMy7hUVFhIaCrNQsKkTIsLivwKKigsj8XYlwt/WKi2N4d//uQRCSAAjURNIHpMZBGYiaQPSYyAAABLAAAAAAAACWAAAAApUF/Mg+0aohSIRobBAsMlO//Kk4soosy1JSFRYWaLC4qZBYWFRGZdwqKiwkNBVmoWFSJkWFxX4FFRQWR+LsS4W/rFRb/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////VEFHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAU291bmRib3kuZGUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMjAwNGh0dHA6Ly93d3cuc291bmRib3kuZGUAAAAAAAAAACU=");  
    snd.play();
}
		
		
		
		var delta = {
			lastTimestamp:0,
			timestamp:0,
			v:0
		};
		function main_loop(time){
			if(delta.timeStamp == 0){
				delta.timeStamp = time;
				window.requestAnimationFrame(main_loop);
				return;
			}else{
				delta.lastTimestamp = delta.timestamp;
				delta.timestamp = time;
				delta.v = (delta.timestamp - delta.lastTimestamp)/1000;
			};
			
			game_loop();
			
			
			updateKeystate();
			window.requestAnimationFrame(main_loop);
		};
		
		function handle_resize(){
			var c = document.getElementById("main_game_canvas");
				c.width = c.height = Math.min(window.innerWidth, window.innerHeight);
		};
		
		//lol
		var keyCodes = {"65":"a", "87":"w", "68":"d", "83":"s", "37":"leftArrow", "39" : "rightArrow", "38":"upArrow", "40":"downArrow"};
		var keyState = {}; Object.keys(keyCodes).forEach((i)=>{ keyState[keyCodes[i]] = {down:false, pressed: false}; });
		
		function updateKeystate(){//update key state clears keyPressed when game loop polls
			for (var k in keyState){ keyState [k].pressed = false; };
		};
		function handle_keydown( e ){
			if(keyState[keyCodes[e.keyCode]].down == false) keyState[keyCodes[e.keyCode]].pressed = true;
			keyState[keyCodes[e.keyCode]].down = true; 
		};
		function handle_keyup ( e ) { keyState[keyCodes[e.keyCode]].down = false; };
		
	
		window.addEventListener("resize", handle_resize);
		window.addEventListener("keydown", handle_keydown);
		window.addEventListener("keyup", handle_keyup);
		handle_resize();
		
		
		
		var gameCanvas = document.getElementById("main_game_canvas");
		var gameCanvasContext = gameCanvas.getContext("2d");
		function game_loop(){
		
			gameCanvasContext.clearRect(0,0, gameCanvas.width, gameCanvas.height);
			
			for(var i = 0; i < caps.length; i++){
				for(var j = i; j < caps.length; j++){
					(caps[i].closestLinePoint(caps[j])).drawOnCanvas(gameCanvasContext);
				}
			};
			
			for(var c of caps){ c.drawOnCanvas(gameCanvasContext)};
			
			
			
		};
		
		
		function startup(){
			window.caps = [
				//new CappedLine(0.4,0.4,0.4, 0.4, 0.05, "blue"),
				//new CappedLine(0.6,0.6,0.6, 0.6, 0.05, "red"),
				CappedLine.getRandom(0.5,0.5, 0.05, "yellow"),
				CappedLine.getRandom(0.5,0.5, 0.05, "blue"),
				CappedLine.getRandom(0.5,0.5, 0.05, "red"),
			];
		};
		
		
		
		
		
		
		//capped lines will be used for character vs character hit detection. A capped line is the union of a line and a circle.
		function CappedLine(x1, y1, x2, y2, radius, drawColor){
			this.x1 = x1, this.x2 = x2, this.y1 = y1, this.y2 = y2;
			this.w = this.x2 - this.x1, this.h = this.y2 - this.y1; 
			this.radius = radius;
			this.drawColor = drawColor;
		};
		
		CappedLine.getRandom = function(xRange, yRange, radiusRange, color){
			return new CappedLine(Math.random(), Math.random(), Math.random(), Math.random(), Math.random() * radiusRange, color );
		};
		
		CappedLine.prototype.isTouchingCappedLine = function( c2 ){
			var distance = this.testCappedLine( c2 );
			
			return (distance < 0);
		};
		
		
		//returns the distance between the edges of two capped lines. if negative they are intersecting.
		CappedLine.prototype.testCappedLine = function( c2 ){
			var smallestVector = this.closestLinePoint(c2);//this is the smallest line that connects both segments.
			var c1 = this;//makes things look prettier
			var radiiSum = c1.radius + c2.radius;
			
			return smallestVector.getMagnitude() - radiiSum;
		};
		
		//this is for the caps as line segments, without cap
		//this code is basically copied directly from real time colission detection. The writer did not see fit to use basic code naming rules making his original code completely illegible.
		//there are a bunch of intermediate forms being used as part of an unclear gaussian elimination.
		CappedLine.prototype.closestLinePoint = function(line2){
			function clamp(a, min, max){if(a < min) return min; if (a > max) return max; return a};
			function isPoint(v){return (Math.abs(v.x) < 0.001 && Math.abs(v.y) < 0.001 );};
			function dot(p1, p2){return p1.x * p2.x + p1.y * p2.y};
			var line1 = this;
			var l1t, l2t;//time along both lines of closest point
			
			var v1 = {x:line1.x2 - line1.x1, y: line1.y2 - line1.y1};
			var v2 = {x:line2.x2 - line2.x1, y: line2.y2 - line2.y1};//direction vectors
			v1.squareMag = dot(v1, v1), v2.squareMag = dot(v2, v2);//square magnitudes, used during projection operations
			var r = {x:line1.x1 - line2.x1, y:line1.y1 - line2.y1}, f = dot(v2, r), b = dot(v1, v2),c = dot(v1, r);
			
			var projectionSegment, denom;
			
			
			if( isPoint(v1) && isPoint(v2) ){//both "segments" degenerate to points;
				return new CappedLine(line1.x1, line1.y1, line2.x1, line2.y1);
			}else if(isPoint(v1)){//first line is point
				l1t = 0;
				projectionSegment = {x:line1.x1  -line2.x1, y:line1.y1 - line2.y1};
				l2t = clamp(dot(projectionSegment, v2) / v2.squareMag, 0, 1 );
			}else if(isPoint(v2)){//second line is point
				l2t = 0;
				projectionSegment = {x:line2.x1  -line1.x1, y:line2.y1 - line1.y1};
				l1t = clamp(dot(projectionSegment, v1) / v1.squareMag, 0, 1 );
			}else{
				//general case
				denom = v1.squareMag * v2.squareMag - b * b;
				
				if(denom!=0){
					l1t = clamp((b * f - c * v2.squareMag)/denom,0,1);
				}else l1t = 0;
				
				l2t = (b * l1t + f ) / v2.squareMag;
				
				if(l2t < 0){
					l2t = 0;
					l1t = clamp(-c / v1.squareMag, 0, 1);
				}else if(l2t > 1){
					l2t = 1;
					l1t = clamp(( b - c) / v1.squareMag, 0, 1);
				};
				
			}
			
			
			
			return new CappedLine(line1.x1 + v1.x * l1t, line1.y1 + v1.y * l1t, line2.x1 + v2.x * l2t, line2.y1 + v2.y * l2t, 0.001);
		};
		
		
		
		CappedLine.prototype.getNormalized = function(){
			var d = this.getMagnitude();
			return {x:(this.x2 - this.x1) / d, y:(this.y2 - this.y1) / d};
		};
		
		CappedLine.prototype.getMagnitude = function(){
			return Math.sqrt(this.w * this.w + this.h * this.h);
		};
		
		CappedLine.prototype.dot = function( point ){
			var thisN = this.getNormalized;
			return thisN.x1 * point.x + thisN.y1 * point.y;
		};
		
		
		CappedLine.prototype.drawOnCanvas = function(cx){
			var w = cx.canvas.width, h = cx.canvas.height;
			cx.save();
			cx.lineWidth = this.radius * 2 * w;
			cx.lineCap = "round";
			cx.globalAlpha = 0.5;
			cx.strokeStyle = (this.drawColor) ? this.drawColor : "white";
			
			cx.beginPath();
			cx.moveTo(this.x1 * w, this.y1 * h);
			cx.lineTo(this.x2 * w, this.y2 * h);
			cx.stroke();
			cx.restore();
		};
		
		startup();
		main_loop();
	</script>
</body>
</html>