<!DOCTYPE html>
<html>
<head>
	<link rel="stylesheet" href="../../game/main.css">
</head>
<body>
	<div id = "main_game_container" class = "fill" >
		<canvas id = "main_game_canvas"></canvas>
	</div>
	
	
	
	
	
	<script>
	//this file exists solely as a proof of concept for the tile collision engine.
	//at first the logic will reside here to provide a functioning example
	//then the logic module will be split off into the main physics system.
	//two 
		function beep() {
    var snd = new Audio("data:audio/wav;base64,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qJrx4KOQjahZxWbcZgztj2c49nKmkId44S71j0c8eV9yDK6uPRzx5X18eDvjvQ6yKo9ZSS6l//8elePK/Lf//IInrOF/FvDoADYAGBMGb7FtErm5MXMlmPAJQVgWta7Zx2go+8xJ0UiCb8LHHdftWyLJE0QIAIsI+UbXu67dZMjmgDGCGl1H+vpF4NSDckSIkk7Vd+sxEhBQMRU8j/12UIRhzSaUdQ+rQU5kGeFxm+hb1oh6pWWmv3uvmReDl0UnvtapVaIzo1jZbf/pD6ElLqSX+rUmOQNpJFa/r+sa4e/pBlAABoAAAAA3CUgShLdGIxsY7AUABPRrgCABdDuQ5GC7DqPQCgbbJUAoRSUj+NIEig0YfyWUho1VBBBA//uQZB4ABZx5zfMakeAAAAmwAAAAF5F3P0w9GtAAACfAAAAAwLhMDmAYWMgVEG1U0FIGCBgXBXAtfMH10000EEEEEECUBYln03TTTdNBDZopopYvrTTdNa325mImNg3TTPV9q3pmY0xoO6bv3r00y+IDGid/9aaaZTGMuj9mpu9Mpio1dXrr5HERTZSmqU36A3CumzN/9Robv/Xx4v9ijkSRSNLQhAWumap82WRSBUqXStV/YcS+XVLnSS+WLDroqArFkMEsAS+eWmrUzrO0oEmE40RlMZ5+ODIkAyKAGUwZ3mVKmcamcJnMW26MRPgUw6j+LkhyHGVGYjSUUKNpuJUQoOIAyDvEyG8S5yfK6dhZc0Tx1KI/gviKL6qvvFs1+bWtaz58uUNnryq6kt5RzOCkPWlVqVX2a/EEBUdU1KrXLf40GoiiFXK///qpoiDXrOgqDR38JB0bw7SoL+ZB9o1RCkQjQ2CBYZKd/+VJxZRRZlqSkKiws0WFxUyCwsKiMy7hUVFhIaCrNQsKkTIsLivwKKigsj8XYlwt/WKi2N4d//uQRCSAAjURNIHpMZBGYiaQPSYyAAABLAAAAAAAACWAAAAApUF/Mg+0aohSIRobBAsMlO//Kk4soosy1JSFRYWaLC4qZBYWFRGZdwqKiwkNBVmoWFSJkWFxX4FFRQWR+LsS4W/rFRb/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////VEFHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAU291bmRib3kuZGUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMjAwNGh0dHA6Ly93d3cuc291bmRib3kuZGUAAAAAAAAAACU=");  
    snd.play();
}
		
		
		
		var delta = {
			lastTimestamp:0,
			timestamp:0,
			v:0
		};
		function main_loop(time){
			if(delta.timeStamp == 0){
				delta.timeStamp = time;
				window.requestAnimationFrame(main_loop);
				return;
			}else{
				delta.lastTimestamp = delta.timestamp;
				delta.timestamp = time;
				delta.v = (delta.timestamp - delta.lastTimestamp)/1000;
			};
			
			
			g.update(delta.v);
			g.draw( document.getElementById("main_game_canvas") );
			
			if(keyState.w.pressed) {beep()};
			updateKeystate();
			window.requestAnimationFrame(main_loop);
		};
		
		function handle_resize(){
			var c = document.getElementById("main_game_canvas");
				c.width = c.height = Math.min(window.innerWidth, window.innerHeight);
		};
		
		//lol
		var keyCodes = {"65":"a", "87":"w", "68":"d", "83":"s", "37":"leftArrow", "39" : "rightArrow", "38":"upArrow", "40":"downArrow"};
		var keyState = {}; Object.keys(keyCodes).forEach((i)=>{ keyState[keyCodes[i]] = {down:false, pressed: false}; });
		
		function updateKeystate(){//update key state clears keyPressed when game loop polls
			for (var k in keyState){ keyState [k].pressed = false; };
		};
		function handle_keydown( e ){
			if(keyState[keyCodes[e.keyCode]].down == false) keyState[keyCodes[e.keyCode]].pressed = true;
			keyState[keyCodes[e.keyCode]].down = true; 
		};
		function handle_keyup ( e ) { keyState[keyCodes[e.keyCode]].down = false; };
		
	
		window.addEventListener("resize", handle_resize);
		window.addEventListener("keydown", handle_keydown);
		window.addEventListener("keyup", handle_keyup);
		handle_resize();
		var g = new Grid(0.05, 0.05, [{x:0.4, y:0.4, w:0.2, h:0.2, fillStyle:"orange"}/*, {x:0.6, y:0.6, w:0.8, h:0.6, fillStyle:"yellow"}*/ ]);
		
		
		
		
		
		
		
		//all dimensions should be spelled out in decimals, 1 is the total canvas
		function Grid(i, j, testBoxes){
			this.i = i, this.j = j, this.testBoxes = testBoxes;
			for(var b of this.testBoxes){b.move = {x:0.4, y:0.0}; b.collisions = [];};
			this.activeBox = this.testBoxes[0];//one that actually moves
			
		};
		
		Grid.prototype.constants = {
			movementX:0.1,//how quickly a box moves
			movementY:0.1
		};

		
		
		
		Grid.prototype.draw  = function( canvas ){
			var cx = canvas.getContext("2d");
			function drawLine( x, y , i, j){
				cx.strokeStyle = "purple"; cx.lineWidth = 2;
				cx.beginPath();cx.moveTo(x, y);cx.lineTo(i, j);cx.stroke();
			};
			
			cx.clearRect(0,0,canvas.width, canvas.height);
			var ii = 0, jj = 0;
			while (ii <= 1){
				drawLine(ii * canvas.width, 0, ii * canvas.width, canvas.height);
				ii+= this.i;
			};
			while (jj <= 1){
				drawLine(0, jj * canvas.height, canvas.width, jj * canvas.height);
				jj+= this.j;
			};
			
				
			for (var b of this.testBoxes){
				cx.fillStyle = b.fillStyle ? b.fillStyle : "black";
				cx.strokeStyle = b.strokeStyle ? b.strokeStyle : "black";
				
				cx.fillRect( b.x * canvas.width, b.y * canvas.height, b.w * canvas.width, b.h * canvas.height );
				this.drawMove(b, canvas, cx, drawLine);
				
				
			};
		};
		
		
		Grid.prototype.drawMove = function(box, canvas, cx, drawLine ){
			var movePoint = {
				x: (box.move.x < 0) ? box.x : box.x + box.w,
				y: (box.move.y < 0) ? box.y : box.y + box.h
			};
			drawLine(movePoint.x * canvas.width, movePoint.y * canvas.height, (movePoint.x + box.move.x) * canvas.width, (movePoint.y + box.move.y) * canvas.height);
			
			for(var i of box.collisions){
				cx.fillStyle = "rgba(0, 0, 255, 0.5)";
				cx.fillRect(i.x * this.i * canvas.width, i.y * this.j * canvas.height, this.i * canvas.width, this.j * canvas.height);
			}
			
			
			
		};
		
		
		Grid.prototype.update = function( delta ){
			for (var i of this.testBoxes){
				this.generateCollisions( i );
			};
	
	
			if(keyState.leftArrow.down && !keyState.rightArrow.down) this.activeBox.x -= this.constants.movementX * delta;
			if(!keyState.leftArrow.down && keyState.rightArrow.down) this.activeBox.x += this.constants.movementX * delta;
			if(keyState.downArrow.down && !keyState.upArrow.down) this.activeBox.y += this.constants.movementY * delta;
			if(!keyState.downArrow.down && keyState.upArrow.down) this.activeBox.y -= this.constants.movementY * delta;
			
			
			if(keyState.a.down && !keyState.d.down) this.activeBox.move.x -= this.constants.movementX * delta;
			if(!keyState.a.down && keyState.d.down) this.activeBox.move.x += this.constants.movementX * delta;
			if(keyState.s.down && !keyState.w.down) this.activeBox.move.y += this.constants.movementY * delta;
			if(!keyState.s.down && keyState.w.down) this.activeBox.move.y -= this.constants.movementY * delta;
		};
		
		
		//this wrapper function feeds the main algorithm positive values then re interprets the results.
		//the below algorith is too difficult to maintain in a direction agnostic way.
		Grid.prototype.generateCollisions = function( box ){
			if(box.move.x == 0 && box.move.y == 0) box.collisions = [];//if its not moving do nothing
			
			
			
			this.sweepBoxInside(box);
		};
		
		//Grid.prototype.sweepBoxInside = function( box ){

		//};
		
		
		
		
		
		
		
		
		
		
		
		//assumes box is moving up and right, wrapper function will negate values according to real box direction
		//compiles all tiles that a box will contact
		Grid.prototype.sweepBoxInside = function( box ){
			box.collisions = [];
			
			//tileCounter holds what tile the end of the line currently resides in as we test
			var tileCounter = {x:Math.floor((box.x+box.w)/this.i), y:Math.floor((box.y+box.h)/this.j)};
			//currentX and currentY are needed to test for tiles clipped by the non active corner
			var currentX = box.x + box.w, currentY = box.y + box.h;
			
			//parametric time it takes for the line to cross from one gridline to another in each direction
			var xGridTime = this.i / box.move.x, yGridTime = this.j / box.move.y;
			//starts with the time when the line first intercepts the next vertical and horizontal gridline
			var xTime = Grid.getLineTime(currentX, box.move.x, (tileCounter.x + 1) * this.i);
			if(xTime < 0.00001)xTime = this.i * (tileCounter.x + 1);
			if(Math.abs(xTime - xGridTime) < 0.00001) xTime = xGridTime;
			var yTime = Grid.getLineTime(currentY, box.move.y, (tileCounter.y + 1) * this.j);
			if(yTime < 0.00001)yTime = this.j * (tileCounter.j + 1);
			if(Math.abs(yTime - yGridTime) < 0.00001) yTime = yGridTime;
			
			var timeCounter = Math.min(xTime, yTime), timeEnd = 1;
			
			
			
			//these variables are used for the inner loop that calculates the side bits
			var crossCounter;
			
			
			while(timeCounter < timeEnd){
				currentX += box.move.x * timeCounter;//update the real x and y values
				currentY += box.move.y * timeCounter;
				
				if(xTime == yTime){//there may be a clever way to circumvent this block of code
				//by selectively not moving some values but I could not figure it out
					xTime += xGridTime; yTime += yGridTime;
					tileCounter.x++; tileCounter.y++;
					crossCounter = box.h / this.j;
					while(crossCounter > 0){
						box.collisions.push({x:tileCounter.x, y:tileCounter.y - crossCounter});
						crossCounter --;
					};
					crossCounter = box.w / this.i;
					while(crossCounter > 0){
						box.collisions.push({x:tileCounter.x - crossCounter, y:tileCounter.y});
						crossCounter --;
					};
				
				
				}else if(xTime < yTime){
					xTime += xGridTime;
					tileCounter.x++;
					
					
				
					crossCounter = Math.floor ( (((currentY - box.h) % this.j ) +box.h ) /this.j  );
					while(crossCounter > 0){
						box.collisions.push({x:tileCounter.x, y:tileCounter.y - crossCounter});
						crossCounter --;
					};
				}else {
					yTime += yGridTime;
					tileCounter.y++;
				
				
					crossCounter = Math.floor ( (((currentX - box.w) % this.i ) +box.w ) /this.i  );
					while(crossCounter > 0){
						box.collisions.push({x:tileCounter.x - crossCounter, y:tileCounter.y});
						crossCounter --;
					};
				};
				
				
				
				
				
				timeCounter = Math.min(xTime, yTime);
				//currently send time of block intersection with output
				box.collisions.push({x:tileCounter.x, y:tileCounter.y});
			}
		};
		
		
		
		Grid.getLineTime = function(zStart, zStep, zTarget){//this helper function determines at what time t a line crosses a specific position
			return (zTarget - zStart) / zStep;
		};
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		var tileBehaviors = {};
		tileBehaviors.SOLID = tileBehaviors[" 0 "] = function(){};
		
		tileBehaviors.ANGLE = tileBehaviors[" 0 "] = function(){
			
		};
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		main_loop();
	</script>
</body>
</html>
